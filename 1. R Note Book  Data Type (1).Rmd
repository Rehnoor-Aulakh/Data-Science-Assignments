---
title: "R Notebook"
output:
  pdf_document: default
  html_notebook: default
---
# Getting Help  
## Finding Answers  

-  Search the archives of the forum before you post
-   Search the web
-   Read the manual
-   Read the FAQ
-   inspection or experimentation
-   Ask a skilled friend
-   Read the source code (if you're a programmer)

## Asking Questions

-   It's important to let other people know you've done due diligence
-   What steps will reproduce the problem?
-   What is the expected output?
-   What did you see instead?
-   What version of the product?
-   What OS?
-   Additional information

## Example

### Error Messages

```{r}
library(datasets)
```

```{r}
data(airquality)
```

```{r}
cov(airquality)#covariance
```

### Google is your Friend

Google: "missing observations in cov/cor"

## Subject Headers

-   Stupid: "Help! can't fit linear model!"
-   Smart: "R 3.0.2 lm() function produces seg fault with large data
    frame, Mac OSX 10.9.1"
-   Smart: "R 3.0.2 lm() function on Mac OSX 10.9.1 -- segfault on large
    data frame"

## Do These

-   Describe the goal, not the step
-   Be explicit about your question
-   Do provide the minimum amount of info necessary
-   Be courteous
-   Follow up with the solution (if found)

## Don't Do These

-   Claim you've found a bug
-   Grovel as a substitute for doing your homework
-   Post homework questions on mailing lists
-   Email multiple emailing lists at once
-   Ask others to debug your code without giving a hist as to what sort
    of problem they should be searching for

# Data Types - Part 1

## Objects

-   Character
-   Numeric
-   Integer
-   Complex
-   Logical (true/false)

The most basic object is a vector:

-   A vector can only contain objects of the same class
-   The one exception is a list

Empty vectors can be created with the vector() function.

## Numbers

-   Numbers in R are generally treated as numeric objects (i.e. double
    precision real numbers)
-   If you explicitly want an integer you need to specify the L suffix
-   There is a special number called Inf which represents infinity
-   The value NaN represents an undefined value

## Attributes

R objects can have attributes

-   names, dimnames
-   dimensions (e.g. matrices, arrays)
-   class
-   length
-   other user-defined attributes/metadata

Attributes of an object can be access using the attributes() function.

## Entering input

At the R prompt we type expressions. The \<- symbol is the assignment
operator.

```{r}
x <- 1
print(x) 
1 -> x
print(x)
x
msg <- "hello"
msg
```

The [1] indicates that x is a vector.

The grammar of the language determines whether an expression is complete
or not.

```{r}
#x<- #incomplete expression
 
```

The \# begins a comment.

```{r}
## Printing
x <- 1:5
x
class(x)
x<-c(1,2,3,4,5)
class(x)
x<-c(1:5)
class(x)
print(x)
```

The : operator is used to create integer sequences.

# Data Types - Part 2

## Creating vectors

The c() function (concatenate) can be used to create vectors of objects:

```{r}
x <- c(0.5, 0.6)      # numeric
x
x <- c(TRUE, FALSE)   # logical
x
x <- c(T, F)          # logical
x
x <- c("a", "6", "c") # character
x
x <- c(9:29)          # integer
x
x <- c(1+0i, 2+4i)    # complex
x
```

Using the vector function:

```{r}
x <- vector("numeric", length = 10)
x

```

## Mixing Objects

What about the following?

```{r}
#Since c is a vector and not a list, it cannot have different data types
y <- c(1.7, "a") # character, 1.7 is converted into "1.7"
y
y <- c(TRUE, 2) # numeric, TRUE is converted into number 
y
y <- c("a", TRUE) # character, TRUE is converted to "TRUE"
y
```

## Explicit Coercion

Object can be explicitly coerced from one class to another using the
as.\* functions, if available.

```{r}
x <- 0:6
class(x)
as.numeric(x)
x
as.logical(x)
x
as.character(x)
x
```

## Explicit Coercion

Nonsensical coercion results in NAs:

```{r}
x <-c("9", "978L", "2+0.5i")
x
as.complex(x)
x
```

```{r}
x<-"false"
as.logical(x)
as.complex(x)
```

## Matrices

Matrices are vectors with a dimension attribute. The dimension attribute
is itself an integer vector of length 2 (nrow, ncol).

```{r}
m<- matrix(nrow=2, ncol=3)
m
dim(m)
attributes(m)

```

Matrices are constructed *column-wise*, so entries can be thought of
starting in the "upper left" corner and running down the columns.

```{r}
m <- matrix(1:6, ncol = 3, nrow = 2)
m

```

Matrices can also be created directly from vectors by adding a dimension
attribute.

```{r}
m <- 1:10
m
dim(m)
#Initially dimension of m is null, because it is integer sequence
dim(m) <- c(2, 5)
m

```

Matrices are also commonly created by *column-binding* or *row-binding*
with cbind() and rbind().

```{r}
x <- 1:3
y <- c("a","b","c")
# x gets converted to character, because matrix must have same data type
z<-cbind(x, y)
z
class(z)
rbind(x, y)

```

## Lists

Lists are a special type of vector that can contain elements of
different classes. Lists are a very important data type in R and you
should get to know them well.

```{r}
x <- list(1, c("a","b"), TRUE, 1 + 4i,m)
x

```

---
Data Types - Part 3
===================

Factors
-------

Factors are used to represent categorical data. Factors can be unordered or ordered. one can think of a factor as an integer vector where each integer has a label.

* Factors are treated specially by R modeling functions like lm() and glm()
* Using factors with labels is better than using integers because factors are self-describing; having a variable that has values "Male" and "Female" is better than a variable that has values 1 and 2

Examples:

```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"))
x
```

```{r} 
table(x)
```
```{r}
unclass(x)
```


The order of the levels can be set using the levels argument to factor(). This can be important in linear modeling because the first level is used as the baseline level.

```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"),levels = c("yes", "no"))
x
table(x)
unclass(x)
print("Attributes object")
attributes(x)
```

Missing values
--------------

Missing values are denoted by NA or NAN for undefined mathematical operations.

* is.na() is used to test if they are NA (missing values)
* is.nan() is used to test for NaN (not a number)
* NA values have  a class also, so there are integer NA and character NA etc
* a NaN value is also NA but the converse is not true

Examples:

```{r}
x <- c(1, 2, NA, 10, 3)
is.na(x)
```

```{r}
is.nan(x)
```

```{r}
x <- c(1, 2, NaN, NA, 4)
is.na(x)
```

```{r}
is.nan(x)
```
-------------------
Data Frame
----------

Data frames are used to store tabular data.

* They are represented as a special type of list where every element of the list has to have the same length
* Each element of the list can be thought of as a column and the length of each element of the list is the number of rows
* Unlike matrices, data frames can store different classes of objects in each column (just like lists); matrices must have every element be the same class
* Data frames also have a special attributes called row.names
* Data frames are usually created by calling read.table() or read.csv()
* Can be converted to a matrix by calling data.matrix()

Examples:

```{r}
x <- data.frame(foo = 1:4, bar = c(T,T,F,F))
x
```
```{r}
nrow(x)
ncol(x)
```

Names

R objects can also have names, which is very useful for writing readable code and self-describing objects.
```{r}
x <- 1:3
names(x)
```
```{r}
names(x) <- c("foo", "bar", "norf")
x
```
```{r}
names(x)
```


Lists can also have names
```{r}
x <- list(a = 1, b = 2, c = 3)
x
```
And matrices:

```{r}

m <- matrix(1:4, nrow = 2, ncol = 2)
dimnames(m) <- list(c("a", "b"), c("c", "d"))
m
```


Summary
-------

* atomic classes: numeric, logical, character, integer, complex
* vectors, lists
* factors
* missing values
* data frames
* names
-----
Subsetting - Part 1
===================

Subsetting
----------

* [ ] always returns an object of the same class as the original; can be used to select more than one element (there is one exception)
* [[ ]]is used to extract elements of a list of data frame; it can only be used to extract a single element and the class of the returned object will not necessarily be a list or data frame
* $ is used to extract elements of a list or data frame by name; semantics are similar to that of [[

Examples:
```{r}
x<- c("a", "b", "c", "c", "d", "a")
x[1]
```
```{r} 
x[2]
```
```{r}
x[1:4]
```
```{r}
u <- x > "a"
u
```
	[1] FALSE TRUE TRUE TRUE TRUE FALSE
```{r}
x
x[u]
```


Subsetting a Matrix
-------------------

Matrices can be subsetted in the usual way with (i,j) type indices.
```{r}
x <- matrix(1:6, 2, 3)
x
x[1, c(3,2)]
```
```{r}
x[2, 1]
```
Indices can also be missing.

```{r}
x[1, ]
```

```{r}
x[ ,2]
```

By default when a single element is retrieved, it is returned as a vector of length 1 rather than a 1 x 1 matrix. This behavior can be turned off by setting drop = FALSE.
```{r}
x <- matrix(1:6, 2, 3)
x
x[1, 2]
```

```{r}
x[1, 2, drop = FALSE]
```
Similarly, subsetting a single column or a single row will give you a vector, not a matrix (by default)

```{r}
x <- matrix(1:6, 2, 3)
x[1, ]
```

```{r}
x[1, , drop = FALSE]
```

===================

Subsetting Lists
----------------

```{r}
x <- list(foo = 1:4, bar = 0.6)
x
x[1]
```

```{r}
x[[1]]
```
```{r}
x$foo
```

```{r}
x[["bar"]]
```


```{r}
x["bar"]
x[["bar"]]
x$bar
```

Another example:

```{r}
x <-list(foo = 1:4, bar = 0.6, baz = "hello")
x[c(1, 3)]
```

The [[ operator can be used with computed indices; $ can only be used with literal names.

```{r}
x <- list(foo = 1:4, bar = 0.6, baz = "hello")
name <- "foo"
x[[name]]
x[["foo"]] # computed index for 'foo'
x$name # element 'name' doesn't exist
x$foo
```


Subsetting Nested Elements of a List
------------------------------------

The [[ can take an integer sequence.

```{r}
x <-list(a = list(10, 12, 14), b = c(3.14, 2.81))
x[[c(1, 3)]]
```
```{r}
x[[1]][[3]]
```
	
```{r}
x[[c(2, 1)]]
```


Partial Matching
----------------

Partial matching of names is allowed with [[ and $

```{r}
x <- list(aardvark = 1.5,eraaaaaa=90)
x$aa
#It should match the beginning 
x$ak
# [[]] performs exact matching by default, if you want partial matching, set exact = FALSE
x[["aar", exact=FALSE]]
```

```{r}
x [["a"]]
```

```{r}
x[["a", exact = FALSE]]
```


Removing NA values
------------------

A common task is to remove missing values (NAs).

```{r}
x <- c(1, 2, NA, 4, NA, 5)
bad <- is.na(x)
x[!bad]
```

What if there are multiple things and you want to take the subset with no missing values?

```{r}
x <- c(1, 2, 6, 4, NA, 5)
y <- c("a", "b", NA, "d", NA, "f")
good <- complete.cases(x, y)
good
```
```{r}
x[good]
```

```{r}
y[good]
```

You can use the complete.cases() function on data frames.
```{r}
#your_data= read.csv('your_data.csv')
#good <- complete.cases(your_data)
#your_data[good,]
```

```{r}	
seq(from=1,to=10)


seq(-1,-10)


seq(5.5,8)

seq(from=1,to=30,by=3)

seq(1,30,2)

seq.int(from=1,to=30, length.out=5)

y<-c(1,5,15,20)
seq(10,30,along.with = y)

seq_len(10)	
```	
